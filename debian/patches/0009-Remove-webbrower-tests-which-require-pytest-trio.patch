From: Alexis Murzeau <amubtdx@gmail.com>
Date: Thu, 21 Sep 2023 23:28:58 +0200
Subject: Remove webbrower tests which require pytest-trio

pytest-trio is not available on bookworm-backports, these tests can't be
run until the backport is available.

Forwarded: not-needed
Author: Alexis Murzeau <amubtdx@gmail.com>
---
 tests/webbrowser/__init__.py            |   0
 tests/webbrowser/cdp/__init__.py        |  33 --
 tests/webbrowser/cdp/conftest.py        |  18 -
 tests/webbrowser/cdp/test_client.py     | 941 --------------------------------
 tests/webbrowser/cdp/test_connection.py | 763 --------------------------
 tests/webbrowser/conftest.py            |  68 ---
 tests/webbrowser/test_chromium.py       | 182 ------
 tests/webbrowser/test_webbrowser.py     | 144 -----
 8 files changed, 2149 deletions(-)
 delete mode 100644 tests/webbrowser/__init__.py
 delete mode 100644 tests/webbrowser/cdp/__init__.py
 delete mode 100644 tests/webbrowser/cdp/conftest.py
 delete mode 100644 tests/webbrowser/cdp/test_client.py
 delete mode 100644 tests/webbrowser/cdp/test_connection.py
 delete mode 100644 tests/webbrowser/conftest.py
 delete mode 100644 tests/webbrowser/test_chromium.py
 delete mode 100644 tests/webbrowser/test_webbrowser.py

diff --git a/tests/webbrowser/__init__.py b/tests/webbrowser/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/tests/webbrowser/cdp/__init__.py b/tests/webbrowser/cdp/__init__.py
deleted file mode 100644
index 094745b..0000000
--- a/tests/webbrowser/cdp/__init__.py
+++ /dev/null
@@ -1,33 +0,0 @@
-# TODO: trio>0.22 release: remove __future__ import (generic memorychannels)
-from __future__ import annotations
-
-from typing import List
-
-import trio
-from trio_websocket import CloseReason, ConnectionClosed  # type: ignore[import]
-
-
-class FakeWebsocketConnection:
-    sender: trio.MemorySendChannel[str]
-    receiver: trio.MemoryReceiveChannel[str]
-
-    def __init__(self) -> None:
-        self.sender, self.receiver = trio.open_memory_channel(10)
-        self.sent: List[str] = []
-        self.closed: bool = False
-
-    async def send_message(self, message: str):
-        self.sent.append(message)
-
-    async def get_message(self):
-        try:
-            return await self.receiver.receive()
-        except BaseException:
-            # noinspection PyTypeChecker
-            raise ConnectionClosed(CloseReason(1000, None)) from None
-
-    async def aclose(self):
-        # sync
-        self.sender.close()
-        self.receiver.close()
-        self.closed = True
diff --git a/tests/webbrowser/cdp/conftest.py b/tests/webbrowser/cdp/conftest.py
deleted file mode 100644
index 5dfc738..0000000
--- a/tests/webbrowser/cdp/conftest.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from unittest.mock import ANY, AsyncMock, call
-
-import pytest
-
-from tests.webbrowser.cdp import FakeWebsocketConnection
-
-
-@pytest.fixture()
-def websocket_connection(monkeypatch: pytest.MonkeyPatch):
-    fake_websocket_connection = FakeWebsocketConnection()
-    mock_connect_websocket_url = AsyncMock(return_value=fake_websocket_connection)
-    monkeypatch.setattr("streamlink.webbrowser.cdp.connection.connect_websocket_url", mock_connect_websocket_url)
-
-    try:
-        yield fake_websocket_connection
-    finally:
-        assert fake_websocket_connection.closed
-        assert mock_connect_websocket_url.call_args_list == [call(ANY, "ws://localhost:1234/fake", max_message_size=2 ** 24)]
diff --git a/tests/webbrowser/cdp/test_client.py b/tests/webbrowser/cdp/test_client.py
deleted file mode 100644
index 9ec55aa..0000000
--- a/tests/webbrowser/cdp/test_client.py
+++ /dev/null
@@ -1,941 +0,0 @@
-from contextlib import nullcontext
-from typing import Awaitable, Callable, Union, cast
-from unittest.mock import ANY, AsyncMock, Mock, call
-
-import pytest
-import trio
-from trio.testing import wait_all_tasks_blocked
-
-from streamlink.session import Streamlink
-from streamlink.webbrowser.cdp.client import CDPClient, CDPClientSession, RequestPausedHandler
-from streamlink.webbrowser.cdp.connection import CDPConnection, CDPSession
-from streamlink.webbrowser.cdp.devtools.fetch import RequestPaused
-from streamlink.webbrowser.cdp.devtools.target import SessionID, TargetID
-from streamlink.webbrowser.cdp.exceptions import CDPError
-from tests.webbrowser.cdp import FakeWebsocketConnection
-
-
-def async_handler(*args, **kwargs):
-    return cast(Union[AsyncMock, Callable[[CDPClientSession, RequestPaused], Awaitable]], AsyncMock(*args, **kwargs))
-
-
-@pytest.fixture()
-def chromium_webbrowser(monkeypatch: pytest.MonkeyPatch):
-    # noinspection PyUnusedLocal
-    def mock_launch(*args, **kwargs):
-        return trio.open_nursery()
-
-    mock_chromium_webbrowser = Mock(
-        launch=Mock(side_effect=mock_launch),
-        get_websocket_url=Mock(return_value="ws://localhost:1234/fake"),
-    )
-    mock_chromium_webbrowser_class = Mock(return_value=mock_chromium_webbrowser)
-    monkeypatch.setattr("streamlink.webbrowser.cdp.client.ChromiumWebbrowser", mock_chromium_webbrowser_class)
-    return mock_chromium_webbrowser
-
-
-@pytest.fixture()
-async def cdp_client(session: Streamlink, chromium_webbrowser: Mock, websocket_connection: FakeWebsocketConnection):
-    async with CDPClient.run(session) as cdp_client:
-        yield cdp_client
-
-
-@pytest.fixture()
-async def cdp_client_session(request: pytest.FixtureRequest, cdp_client: CDPClient):
-    target_id = TargetID("01234")
-    session_id = SessionID("56789")
-    session = cdp_client.cdp_connection.sessions[session_id] = CDPSession(
-        cdp_client.cdp_connection.websocket,
-        target_id=target_id,
-        session_id=session_id,
-        cmd_timeout=cdp_client.cdp_connection.cmd_timeout,
-    )
-    fail_unhandled_requests = getattr(request, "param", False)
-    return CDPClientSession(cdp_client, session, fail_unhandled_requests)
-
-
-class TestLaunch:
-    @pytest.fixture()
-    def cdp_client(self):
-        return Mock()
-
-    @pytest.fixture(autouse=True)
-    def mock_run(self, monkeypatch: pytest.MonkeyPatch, cdp_client: Mock):
-        mock_run = Mock(return_value=Mock(
-            __aenter__=AsyncMock(return_value=cdp_client),
-            __aexit__=AsyncMock(),
-        ))
-        monkeypatch.setattr(CDPClient, "run", mock_run)
-        return mock_run
-
-    @pytest.fixture(autouse=True)
-    def _mock_launch(self, request: pytest.FixtureRequest, session: Streamlink, mock_run, cdp_client: Mock):
-        result = object()
-        mock_runner = AsyncMock(return_value=result)
-        with getattr(request, "param", nullcontext()):
-            assert CDPClient.launch(session, mock_runner) is result
-            assert mock_runner.await_args_list == [call(cdp_client)]
-
-    @pytest.mark.parametrize(("session", "options"), [
-        pytest.param(
-            {},
-            dict(executable=None, timeout=20.0, cdp_host=None, cdp_port=None, cdp_timeout=2.0, headless=True),
-            id="Default options",
-        ),
-        pytest.param(
-            {
-                "webbrowser-executable": "foo",
-                "webbrowser-timeout": 123.45,
-                "webbrowser-cdp-host": "::1",
-                "webbrowser-cdp-port": 1234,
-                "webbrowser-cdp-timeout": 12.34,
-                "webbrowser-headless": False,
-            },
-            dict(executable="foo", timeout=123.45, cdp_host="::1", cdp_port=1234, cdp_timeout=12.34, headless=False),
-            id="Custom options",
-        ),
-    ], indirect=["session"])
-    def test_options(self, session: Streamlink, mock_run: Mock, options: dict):
-        assert mock_run.call_args_list == [call(session=session, **options)]
-
-    # noinspection PyTestParametrized
-    @pytest.mark.usefixtures("_mock_launch")
-    @pytest.mark.parametrize(("session", "_mock_launch"), [
-        pytest.param(
-            {"webbrowser": False},
-            pytest.raises(CDPError, match="^The webbrowser API has been disabled by the user$"),
-            id="Raises CDPError",
-        ),
-    ], indirect=["session", "_mock_launch"])
-    def test_disabled(self, session: Streamlink, mock_run):
-        assert not mock_run.called
-
-
-class TestRun:
-    @pytest.mark.trio()
-    async def test_no_session(
-        self,
-        session: Streamlink,
-        chromium_webbrowser: Mock,
-        cdp_client: CDPClient,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert isinstance(cdp_client, CDPClient)
-        assert isinstance(cdp_client.cdp_connection, CDPConnection)
-        assert isinstance(cdp_client.nursery, trio.Nursery)
-        assert chromium_webbrowser.launch.called
-        assert chromium_webbrowser.get_websocket_url.call_args_list == [call(session)]
-        assert websocket_connection.sent == []
-
-    @pytest.mark.trio()
-    @pytest.mark.parametrize("fail_unhandled_requests", [False, True])
-    async def test_session(
-        self,
-        cdp_client: CDPClient,
-        websocket_connection: FakeWebsocketConnection,
-        fail_unhandled_requests,
-    ):
-        client_session = None
-
-        async def new_session():
-            nonlocal client_session
-            async with cdp_client.session(fail_unhandled_requests=fail_unhandled_requests) as client_session:
-                pass
-
-        async with trio.open_nursery() as nursery:
-            nursery.start_soon(new_session)
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{"targetId":"01234"}}""")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":1,"result":{"sessionId":"56789"}}""")
-
-        assert isinstance(client_session, CDPClientSession)
-        assert isinstance(client_session.cdp_session, CDPSession)
-        assert client_session._fail_unhandled == fail_unhandled_requests
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Target.createTarget","params":{"url":""}}""",
-            """{"id":1,"method":"Target.attachToTarget","params":{"flatten":true,"targetId":"01234"}}""",
-        ]
-
-
-class TestEvaluate:
-    @pytest.mark.trio()
-    async def test_success(self, cdp_client_session: CDPClientSession, websocket_connection: FakeWebsocketConnection):
-        result = None
-
-        async def evaluate():
-            nonlocal result
-            result = await cdp_client_session.evaluate("new Promise(r=>r('foo'))")
-
-        async with trio.open_nursery() as nursery:
-            nursery.start_soon(evaluate)
-            await wait_all_tasks_blocked()
-            await websocket_connection.sender.send(
-                """{"id":0,"sessionId":"56789","result":{"result":{"type":"string","value":"foo"}}}""",
-            )
-
-        assert result == "foo"
-
-    @pytest.mark.trio()
-    async def test_exception(self, cdp_client_session: CDPClientSession, websocket_connection: FakeWebsocketConnection):
-        with pytest.raises(CDPError, match="^SyntaxError: Invalid regular expression: missing /$"):  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_client_session.evaluate, "/")
-
-                await wait_all_tasks_blocked()
-                # language=json
-                await websocket_connection.sender.send("""
-                    {"id":0, "sessionId":"56789", "result": {
-                        "result": {"type": "object", "subclass": "error"},
-                        "exceptionDetails": {
-                            "exceptionId": 1,
-                            "text": "Uncaught",
-                            "lineNumber": 0,
-                            "columnNumber": 0,
-                            "exception": {
-                                "type": "object",
-                                "subtype": "error",
-                                "className": "SyntaxError",
-                                "description": "SyntaxError: Invalid regular expression: missing /"
-                            }
-                        }
-                    }}
-                """)
-
-    @pytest.mark.trio()
-    async def test_error(self, cdp_client_session: CDPClientSession, websocket_connection: FakeWebsocketConnection):
-        with pytest.raises(CDPError, match="^Error: foo\\n    at <anonymous>:1:1$"):  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_client_session.evaluate, "new Error('foo')")
-
-                await wait_all_tasks_blocked()
-                # language=json
-                await websocket_connection.sender.send("""
-                    {"id":0, "sessionId":"56789", "result": {
-                        "result": {
-                            "type": "object",
-                            "subtype": "error",
-                            "className": "Error",
-                            "description": "Error: foo\\n    at <anonymous>:1:1"
-                        }
-                    }}
-                """)
-
-
-class TestRequestPausedHandler:
-    @pytest.mark.parametrize(("url_pattern", "regex_pattern"), [
-        pytest.param(
-            r"abc?def?xyz",
-            r"^abc.def.xyz$",
-            id="Question mark",
-        ),
-        pytest.param(
-            r"abc*def*xyz",
-            r"^abc.+def.+xyz$",
-            id="Star",
-        ),
-        pytest.param(
-            r"^(.[a-z])\d$",
-            r"^\^\(\.\[a\-z\]\)\\d\$$",
-            id="Special characters",
-        ),
-        pytest.param(
-            r"abc\?def\*xyz",
-            r"^abc\?def\*xyz$",
-            id="Escaped question mark and star",
-        ),
-        pytest.param(
-            r"abc\\?def\\*xyz",
-            r"^abc\\\\.def\\\\.+xyz$",
-            id="2 escape characters",
-        ),
-        pytest.param(
-            r"abc\\\?def\\\*xyz",
-            r"^abc\\\\\?def\\\\\*xyz$",
-            id="3 escape characters",
-        ),
-        pytest.param(
-            r"abc\\\\?def\\\\*xyz",
-            r"^abc\\\\\\\\.def\\\\\\\\.+xyz$",
-            id="4 escape characters",
-        ),
-        pytest.param(
-            r"abc\\\\\?def\\\\\*xyz",
-            r"^abc\\\\\\\\\?def\\\\\\\\\*xyz$",
-            id="5 escape characters",
-        ),
-        pytest.param(
-            r"http://*.name.tld/foo\?bar=baz",
-            r"^http://.+\.name\.tld/foo\?bar=baz$",
-            id="Typical URL pattern",
-        ),
-    ])
-    def test_url_pattern_to_regex_pattern(self, url_pattern: str, regex_pattern: str):
-        assert RequestPausedHandler._url_pattern_to_regex_pattern(url_pattern).pattern == regex_pattern
-
-    @pytest.mark.trio()
-    async def test_client_registration(self, cdp_client_session: CDPClientSession):
-        assert len(cdp_client_session._request_handlers) == 0
-        cdp_client_session.add_request_handler(async_handler())
-        cdp_client_session.add_request_handler(async_handler(), on_request=True)
-        cdp_client_session.add_request_handler(async_handler(), url_pattern="foo")
-        cdp_client_session.add_request_handler(async_handler(), url_pattern="foo", on_request=True)
-        assert len(cdp_client_session._request_handlers) == 4
-        assert all(request_handler.async_handler for request_handler in cdp_client_session._request_handlers)
-        assert all(request_handler.url_pattern == "*" for request_handler in cdp_client_session._request_handlers[:2])
-        assert all(request_handler.url_pattern == "foo" for request_handler in cdp_client_session._request_handlers[2:])
-        assert not cdp_client_session._request_handlers[0].on_request
-        assert not cdp_client_session._request_handlers[2].on_request
-        assert cdp_client_session._request_handlers[1].on_request
-        assert cdp_client_session._request_handlers[3].on_request
-
-    @pytest.mark.parametrize(("args", "matches"), [
-        pytest.param(
-            dict(async_handler=async_handler(), on_request=False),
-            False,
-            id="On response - Any URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), on_request=True),
-            True,
-            id="On request - Any URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://localhost/", on_request=True),
-            True,
-            id="Matching URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://l?c?l*/", on_request=True),
-            True,
-            id="Matching wildcard URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://other/", on_request=True),
-            False,
-            id="Non-matching URL",
-        ),
-    ])
-    def test_matches_request(self, args: dict, matches: bool):
-        request = RequestPaused.from_json({
-            "requestId": "request-1",
-            "frameId": "frame-1",
-            "request": {
-                "url": "http://localhost/",
-                "method": "GET",
-                "headers": {},
-                "initialPriority": "VeryHigh",
-                "referrerPolicy": "strict-origin-when-cross-origin",
-            },
-            "resourceType": "Document",
-        })
-        request_handler = RequestPausedHandler(**args)
-        assert request_handler.matches(request) is matches
-
-    @pytest.mark.parametrize(("args", "matches"), [
-        pytest.param(
-            dict(async_handler=async_handler(), on_request=False),
-            True,
-            id="On response - Any URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), on_request=True),
-            False,
-            id="On request - Any URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://localhost/", on_request=False),
-            True,
-            id="Matching URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://l?c?l*/", on_request=False),
-            True,
-            id="Matching wildcard URL",
-        ),
-        pytest.param(
-            dict(async_handler=async_handler(), url_pattern="http://other/", on_request=False),
-            False,
-            id="Non-matching URL",
-        ),
-    ])
-    def test_matches_response(self, args: dict, matches: bool):
-        request = RequestPaused.from_json({
-            "requestId": "request-1",
-            "frameId": "frame-1",
-            "request": {
-                "url": "http://localhost/",
-                "method": "GET",
-                "headers": {},
-                "initialPriority": "VeryHigh",
-                "referrerPolicy": "strict-origin-when-cross-origin",
-            },
-            "resourceType": "Document",
-            "responseStatusCode": 200,
-        })
-        request_handler = RequestPausedHandler(**args)
-        assert request_handler.matches(request) is matches
-
-
-class TestNavigate:
-    @pytest.mark.trio()
-    async def test_detach(self, cdp_client_session: CDPClientSession, websocket_connection: FakeWebsocketConnection):
-        async def navigate():
-            async with cdp_client_session.navigate("https://foo"):
-                pass  # pragma: no cover
-
-        with pytest.raises(CDPError, match="^Target has been detached$"):  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(navigate)
-
-                await wait_all_tasks_blocked()
-                await websocket_connection.sender.send(
-                    """{"method":"Target.detachedFromTarget","params":{"sessionId":"unknown"}}""",
-                )
-                await wait_all_tasks_blocked()
-                await websocket_connection.sender.send(
-                    """{"method":"Target.detachedFromTarget","params":{"sessionId":"56789"}}""",
-                )
-
-    @pytest.mark.trio()
-    async def test_error(self, cdp_client_session: CDPClientSession, websocket_connection: FakeWebsocketConnection):
-        async def navigate():
-            async with cdp_client_session.navigate("https://foo"):
-                pass  # pragma: no cover
-
-        with pytest.raises(CDPError, match="^Navigation error: failure$"):  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(navigate)
-
-                await wait_all_tasks_blocked()
-                assert websocket_connection.sent == [
-                    """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-                ]
-
-                await websocket_connection.sender.send(
-                    """{"id":0,"result":{},"sessionId":"56789"}""",
-                )
-                await wait_all_tasks_blocked()
-                assert websocket_connection.sent == [
-                    """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-                    """{"id":1,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-                ]
-
-                await websocket_connection.sender.send(
-                    """{"id":1,"result":{"frameId":"frame-id-1","errorText":"failure"},"sessionId":"56789"}""",
-                )
-                await wait_all_tasks_blocked()
-                assert websocket_connection.sent == [
-                    """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-                    """{"id":1,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-                    """{"id":2,"method":"Page.disable","sessionId":"56789"}""",
-                ]
-
-                await websocket_connection.sender.send(
-                    """{"id":2,"result":{},"sessionId":"56789"}""",
-                )
-
-    @pytest.mark.trio()
-    async def test_loaded(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        nursery: trio.Nursery,
-    ):
-        loaded = False
-
-        async def navigate():
-            nonlocal loaded
-            async with cdp_client_session.navigate("https://foo") as frame_id:
-                assert frame_id == "frame-id-1"
-                await cdp_client_session.loaded(frame_id)
-                loaded = True
-
-        nursery.start_soon(navigate)
-
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":0,"result":{},"sessionId":"56789"}""",
-        )
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":1,"result":{"frameId":"frame-id-1"},"sessionId":"56789"}""",
-        )
-        await wait_all_tasks_blocked()
-        await websocket_connection.sender.send(
-            """{"method":"Page.frameStoppedLoading","params":{"frameId":"frame-id-unknown"},"sessionId":"56789"}""",
-        )
-        await wait_all_tasks_blocked()
-        await websocket_connection.sender.send(
-            """{"method":"Page.frameStoppedLoading","params":{"frameId":"frame-id-1"},"sessionId":"56789"}""",
-        )
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Page.enable","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-            """{"id":2,"method":"Page.disable","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":2,"result":{},"sessionId":"56789"}""",
-        )
-
-        assert loaded
-
-    @pytest.mark.trio()
-    @pytest.mark.parametrize(("on_request", "fetch_enable_params"), [
-        pytest.param(
-            (False,),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Response","urlPattern":"*"},"""
-                + """{"requestStage":"Response","urlPattern":"http://foo"}]}"""
-            ),
-            id="Single request handler, on response",
-        ),
-        pytest.param(
-            (True,),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Request","urlPattern":"*"},"""
-                + """{"requestStage":"Request","urlPattern":"http://foo"}]}"""
-            ),
-            id="Single request handler, on request",
-        ),
-        pytest.param(
-            (False, False),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Response","urlPattern":"*"},"""
-                + """{"requestStage":"Response","urlPattern":"http://foo"}]}"""
-            ),
-            id="Multiple request handlers, on response",
-        ),
-        pytest.param(
-            (True, True),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Request","urlPattern":"*"},"""
-                + """{"requestStage":"Request","urlPattern":"http://foo"}]}"""
-            ),
-            id="Multiple request handlers, on request",
-        ),
-        pytest.param(
-            (False, True),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Response","urlPattern":"*"},"""
-                + """{"requestStage":"Request","urlPattern":"*"},{"requestStage":"Response","urlPattern":"http://foo"},"""
-                + """{"requestStage":"Request","urlPattern":"http://foo"}]}"""
-            ),
-            id="Multiple request handlers, on response and on request",
-        ),
-        pytest.param(
-            (True, False),
-            (
-                """{"handleAuthRequests":true,"patterns":[{"requestStage":"Response","urlPattern":"*"},"""
-                + """{"requestStage":"Request","urlPattern":"*"},{"requestStage":"Response","urlPattern":"http://foo"},"""
-                + """{"requestStage":"Request","urlPattern":"http://foo"}]}"""
-            ),
-            id="Multiple request handlers, on request and on response",
-        ),
-    ])
-    async def test_fetch_enable(
-        self,
-        monkeypatch: pytest.MonkeyPatch,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        nursery: trio.Nursery,
-        on_request: tuple,
-        fetch_enable_params: str,
-    ):
-        mock_on_fetch_request_paused = AsyncMock()
-        monkeypatch.setattr(cdp_client_session, "_on_fetch_request_paused", mock_on_fetch_request_paused)
-
-        for _on_request in on_request:
-            cdp_client_session.add_request_handler(async_handler(), on_request=_on_request)
-            cdp_client_session.add_request_handler(async_handler(), on_request=_on_request)
-            cdp_client_session.add_request_handler(async_handler(), url_pattern="http://foo", on_request=_on_request)
-
-        async def navigate():
-            async with cdp_client_session.navigate("https://foo"):
-                pass  # pragma: no cover
-
-        assert not mock_on_fetch_request_paused.called
-
-        nursery.start_soon(navigate)
-
-        await wait_all_tasks_blocked()
-        assert mock_on_fetch_request_paused.called
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.enable","params":""" + fetch_enable_params + ""","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":0,"result":{},"sessionId":"56789"}""",
-        )
-
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.enable","params":""" + fetch_enable_params + ""","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.enable","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":1,"result":{},"sessionId":"56789"}""",
-        )
-
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.enable","params":""" + fetch_enable_params + ""","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.enable","sessionId":"56789"}""",
-            """{"id":2,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":2,"result":{"frameId":"frame-id-1"},"sessionId":"56789"}""",
-        )
-
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.enable","params":""" + fetch_enable_params + ""","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.enable","sessionId":"56789"}""",
-            """{"id":2,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-            """{"id":3,"method":"Page.disable","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":3,"result":{},"sessionId":"56789"}""",
-        )
-
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.enable","params":""" + fetch_enable_params + ""","sessionId":"56789"}""",
-            """{"id":1,"method":"Page.enable","sessionId":"56789"}""",
-            """{"id":2,"method":"Page.navigate","params":{"url":"https://foo"},"sessionId":"56789"}""",
-            """{"id":3,"method":"Page.disable","sessionId":"56789"}""",
-            """{"id":4,"method":"Fetch.disable","sessionId":"56789"}""",
-        ]
-        await websocket_connection.sender.send(
-            """{"id":4,"result":{},"sessionId":"56789"}""",
-        )
-
-
-class TestRequestMethods:
-    @pytest.fixture()
-    def req_paused(self):
-        return RequestPaused.from_json({
-            "requestId": "request-1",
-            "frameId": "frame-1",
-            "request": {
-                "url": "http://foo/",
-                "method": "GET",
-                "headers": {},
-                "initialPriority": "VeryHigh",
-                "referrerPolicy": "strict-origin-when-cross-origin",
-            },
-            "resourceType": "Document",
-        })
-
-    @pytest.mark.trio()
-    async def test_continue_request(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        req_paused: RequestPaused,
-        nursery: trio.Nursery,
-    ):
-        nursery.start_soon(cdp_client_session.continue_request, req_paused, "http://bar", "POST", "data", {"a": "b", "c": "d"})
-
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert websocket_connection.sent == [
-            (
-                """{"id":0,"method":"Fetch.continueRequest","params":"""
-                + """{"headers":[{"name":"a","value":"b"},{"name":"c","value":"d"}],"method":"POST","""
-                + """"postData":"ZGF0YQ==","requestId":"request-1","url":"http://bar"},"sessionId":"56789"}"""
-            ),
-        ]
-
-        await websocket_connection.sender.send("""{"id":0,"result":{},"sessionId":"56789"}""")
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-
-    @pytest.mark.trio()
-    async def test_fail_request(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        req_paused: RequestPaused,
-        nursery: trio.Nursery,
-    ):
-        nursery.start_soon(cdp_client_session.fail_request, req_paused, "TimedOut")
-
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert websocket_connection.sent == [
-            (
-                """{"id":0,"method":"Fetch.failRequest","params":"""
-                + """{"errorReason":"TimedOut","requestId":"request-1"},"sessionId":"56789"}"""
-            ),
-        ]
-
-        await websocket_connection.sender.send("""{"id":0,"result":{},"sessionId":"56789"}""")
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-
-    @pytest.mark.trio()
-    async def test_fulfill_request(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        req_paused: RequestPaused,
-        nursery: trio.Nursery,
-    ):
-        nursery.start_soon(cdp_client_session.fulfill_request, req_paused, 404, {"a": "b", "c": "d"}, "data")
-
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert websocket_connection.sent == [
-            (
-                """{"id":0,"method":"Fetch.fulfillRequest","params":"""
-                + """{"body":"ZGF0YQ==","requestId":"request-1","responseCode":404,"""
-                + """"responseHeaders":[{"name":"a","value":"b"},{"name":"c","value":"d"}]},"sessionId":"56789"}"""
-            ),
-        ]
-
-        await websocket_connection.sender.send("""{"id":0,"result":{},"sessionId":"56789"}""")
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-
-    @pytest.mark.trio()
-    async def test_alter_request(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        req_paused: RequestPaused,
-        nursery: trio.Nursery,
-    ):
-        async def alter_request():
-            async with cdp_client_session.alter_request(req_paused, 404, {"a": "b", "c": "d"}) as cmproxy:
-                assert cmproxy.body == ""
-                cmproxy.body = "foo"
-
-        nursery.start_soon(alter_request)
-
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert websocket_connection.sent == [
-            (
-                """{"id":0,"method":"Fetch.fulfillRequest","params":"""
-                + """{"body":"Zm9v","requestId":"request-1","responseCode":404,"""
-                + """"responseHeaders":[{"name":"a","value":"b"},{"name":"c","value":"d"}]},"sessionId":"56789"}"""
-            ),
-        ]
-
-        await websocket_connection.sender.send("""{"id":0,"result":{},"sessionId":"56789"}""")
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-
-    @pytest.mark.trio()
-    async def test_alter_request_response(
-        self,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        req_paused: RequestPaused,
-        nursery: trio.Nursery,
-    ):
-        # turn the request into a response
-        req_paused.response_status_code = 200
-
-        async def alter_request():
-            async with cdp_client_session.alter_request(req_paused, 404, {"a": "b", "c": "d"}) as cmproxy:
-                assert cmproxy.body == "foo"
-                assert cmproxy.response_code == 404
-                assert cmproxy.response_headers == {"a": "b", "c": "d"}
-                cmproxy.body = cmproxy.body.upper()
-                cmproxy.response_code -= 3
-                cmproxy.response_headers["c"] = "e"
-
-        nursery.start_soon(alter_request)
-
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.getResponseBody","params":{"requestId":"request-1"},"sessionId":"56789"}""",
-        ]
-
-        await websocket_connection.sender.send(
-            """{"id":0,"result":{"body":"Zm9v","base64Encoded":true},"sessionId":"56789"}""",
-        )
-        await wait_all_tasks_blocked()
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fetch.getResponseBody","params":{"requestId":"request-1"},"sessionId":"56789"}""",
-            (
-                """{"id":1,"method":"Fetch.fulfillRequest","params":"""
-                + """{"body":"Rk9P","requestId":"request-1","responseCode":401,"""
-                + """"responseHeaders":[{"name":"a","value":"b"},{"name":"c","value":"e"}]},"sessionId":"56789"}"""
-            ),
-        ]
-
-        await websocket_connection.sender.send("""{"id":1,"result":{},"sessionId":"56789"}""")
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-
-
-class TestOnFetchRequestPaused:
-    @pytest.mark.trio()
-    async def test_unhandled_continue(
-        self,
-        monkeypatch: pytest.MonkeyPatch,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        nursery: trio.Nursery,
-    ):
-        mock_fail_request = AsyncMock()
-        mock_continue_request = AsyncMock()
-        monkeypatch.setattr(cdp_client_session, "fail_request", mock_fail_request)
-        monkeypatch.setattr(cdp_client_session, "continue_request", mock_continue_request)
-
-        handler_foo = async_handler()
-        handler_bar = async_handler()
-        cdp_client_session.add_request_handler(handler_foo, url_pattern="http://foo/")
-        cdp_client_session.add_request_handler(handler_bar, url_pattern="http://bar/")
-
-        nursery.start_soon(cdp_client_session._on_fetch_request_paused)
-        await wait_all_tasks_blocked()
-
-        # language=json
-        await websocket_connection.sender.send("""
-            {
-                "method": "Fetch.requestPaused",
-                "params": {
-                    "requestId": "request-1",
-                    "frameId": "frame-1",
-                    "request": {
-                        "url": "http://bar/",
-                        "method": "GET",
-                        "headers": {},
-                        "initialPriority": "VeryHigh",
-                        "referrerPolicy": "strict-origin-when-cross-origin"
-                    },
-                    "resourceType": "Document",
-                    "responseStatusCode": 200
-                },
-                "sessionId": "56789"
-            }
-        """)
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert handler_foo.call_args_list == []
-        assert handler_bar.call_args_list == [call(cdp_client_session, ANY)]
-        assert isinstance(handler_bar.call_args_list[0][0][1], RequestPaused)
-        assert mock_fail_request.call_args_list == []
-        assert mock_continue_request.call_args_list == [call(ANY)]
-        assert isinstance(mock_continue_request.call_args_list[0][0][0], RequestPaused)
-
-    @pytest.mark.trio()
-    async def test_unhandled_fail(
-        self,
-        monkeypatch: pytest.MonkeyPatch,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        nursery: trio.Nursery,
-    ):
-        # make unhandled requests fail
-        cdp_client_session._fail_unhandled = True
-
-        mock_fail_request = AsyncMock()
-        mock_continue_request = AsyncMock()
-        monkeypatch.setattr(cdp_client_session, "fail_request", mock_fail_request)
-        monkeypatch.setattr(cdp_client_session, "continue_request", mock_continue_request)
-
-        handler_foo = async_handler()
-        handler_bar = async_handler()
-        cdp_client_session.add_request_handler(handler_foo, url_pattern="http://foo/")
-        cdp_client_session.add_request_handler(handler_bar, url_pattern="http://bar/")
-
-        nursery.start_soon(cdp_client_session._on_fetch_request_paused)
-        await wait_all_tasks_blocked()
-
-        # language=json
-        await websocket_connection.sender.send("""
-            {
-                "method": "Fetch.requestPaused",
-                "params": {
-                    "requestId": "request-1",
-                    "frameId": "frame-1",
-                    "request": {
-                        "url": "http://bar/",
-                        "method": "GET",
-                        "headers": {},
-                        "initialPriority": "VeryHigh",
-                        "referrerPolicy": "strict-origin-when-cross-origin"
-                    },
-                    "resourceType": "Document",
-                    "responseStatusCode": 200
-                },
-                "sessionId": "56789"
-            }
-        """)
-        await wait_all_tasks_blocked()
-        assert "request-1" not in cdp_client_session._requests_handled
-        assert handler_foo.call_args_list == []
-        assert handler_bar.call_args_list == [call(cdp_client_session, ANY)]
-        assert isinstance(handler_bar.call_args_list[0][0][1], RequestPaused)
-        assert mock_fail_request.call_args_list == [call(ANY)]
-        assert mock_continue_request.call_args_list == []
-        assert isinstance(mock_fail_request.call_args_list[0][0][0], RequestPaused)
-
-    @pytest.mark.trio()
-    async def test_handled(
-        self,
-        monkeypatch: pytest.MonkeyPatch,
-        cdp_client_session: CDPClientSession,
-        websocket_connection: FakeWebsocketConnection,
-        nursery: trio.Nursery,
-    ):
-        # make unhandled requests fail
-        cdp_client_session._fail_unhandled = True
-
-        mock_fail_request = AsyncMock()
-        mock_continue_request = AsyncMock()
-        monkeypatch.setattr(cdp_client_session, "fail_request", mock_fail_request)
-        monkeypatch.setattr(cdp_client_session, "continue_request", mock_continue_request)
-
-        def mock_handled(_cdp_client_session: CDPClientSession, request: RequestPaused):
-            # pretend that we've called any of the request methods which register that the request was handled appropriately
-            _cdp_client_session._requests_handled.add(request.request_id)
-
-        handler_foo = async_handler()
-        handler_bar = async_handler(side_effect=mock_handled)
-        cdp_client_session.add_request_handler(handler_foo, url_pattern="http://foo/")
-        cdp_client_session.add_request_handler(handler_bar, url_pattern="http://bar/")
-
-        nursery.start_soon(cdp_client_session._on_fetch_request_paused)
-        await wait_all_tasks_blocked()
-
-        # language=json
-        await websocket_connection.sender.send("""
-            {
-                "method": "Fetch.requestPaused",
-                "params": {
-                    "requestId": "request-1",
-                    "frameId": "frame-1",
-                    "request": {
-                        "url": "http://bar/",
-                        "method": "GET",
-                        "headers": {},
-                        "initialPriority": "VeryHigh",
-                        "referrerPolicy": "strict-origin-when-cross-origin"
-                    },
-                    "resourceType": "Document",
-                    "responseStatusCode": 200
-                },
-                "sessionId": "56789"
-            }
-        """)
-        await wait_all_tasks_blocked()
-        assert "request-1" in cdp_client_session._requests_handled
-        assert handler_foo.call_args_list == []
-        assert handler_bar.call_args_list == [call(cdp_client_session, ANY)]
-        assert isinstance(handler_bar.call_args_list[0][0][1], RequestPaused)
-        assert mock_fail_request.call_args_list == []
-        assert mock_continue_request.call_args_list == []
diff --git a/tests/webbrowser/cdp/test_connection.py b/tests/webbrowser/cdp/test_connection.py
deleted file mode 100644
index 7666b20..0000000
--- a/tests/webbrowser/cdp/test_connection.py
+++ /dev/null
@@ -1,763 +0,0 @@
-from contextlib import nullcontext
-from dataclasses import dataclass
-from functools import partial
-from typing import Dict, Generator, Optional, Type
-from unittest.mock import AsyncMock
-
-import pytest
-import trio
-from trio.testing import MockClock, wait_all_tasks_blocked
-from trio_websocket import CloseReason, ConnectionClosed, ConnectionTimeout  # type: ignore[import]
-
-from streamlink.webbrowser.cdp.connection import CDPConnection, CDPEventListener, CDPSession
-from streamlink.webbrowser.cdp.devtools.target import SessionID, TargetID
-from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT
-from streamlink.webbrowser.cdp.exceptions import CDPError
-from tests.webbrowser.cdp import FakeWebsocketConnection
-
-
-EPSILON = 0.1
-
-
-@dataclass
-class FakeCommand(str):
-    value: str
-
-    def to_json(self) -> T_JSON_DICT:
-        return {"value": self.value}
-
-    @classmethod
-    def from_json(cls, data: T_JSON_DICT):
-        return cls(data["value"])
-
-
-def fake_command(command: FakeCommand) -> Generator[T_JSON_DICT, T_JSON_DICT, FakeCommand]:
-    json: T_JSON_DICT
-    json = yield {"method": "Fake.fakeCommand", "params": command.to_json()}
-    return FakeCommand.from_json(json)
-
-
-def bad_command() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
-    yield {"method": "Fake.badCommand", "params": {}}
-    yield {}
-
-
-@dataclass
-class FakeEvent:
-    value: str
-
-    @classmethod
-    def from_json(cls, data: T_JSON_DICT):
-        return cls(data["value"])
-
-
-@pytest.fixture()
-async def cdp_connection(websocket_connection: FakeWebsocketConnection):
-    try:
-        async with CDPConnection.create("ws://localhost:1234/fake") as cdp_connection:
-            assert isinstance(cdp_connection, CDPConnection)
-            assert not websocket_connection.closed
-            try:
-                yield cdp_connection
-            finally:
-                await cdp_connection.aclose()
-                assert cdp_connection.sessions == {}
-    finally:
-        assert websocket_connection.closed
-
-
-class TestCreateConnection:
-    @pytest.mark.trio()
-    async def test_success(self, cdp_connection: CDPConnection):
-        assert cdp_connection.target_id is None
-        assert cdp_connection.session_id is None
-
-    @pytest.mark.trio()
-    async def test_failure(self, monkeypatch: pytest.MonkeyPatch):
-        fake_connect_websocket_url = AsyncMock(side_effect=ConnectionTimeout)
-        monkeypatch.setattr("streamlink.webbrowser.cdp.connection.connect_websocket_url", fake_connect_websocket_url)
-        with pytest.raises(ConnectionTimeout):
-            async with CDPConnection.create("ws://localhost:1234/fake"):
-                pass
-
-    @pytest.mark.trio()
-    @pytest.mark.parametrize(("timeout", "expected"), [
-        pytest.param(None, 2, id="Default value of 2 seconds"),
-        pytest.param(0, 2, id="No timeout uses default value"),
-        pytest.param(3, 3, id="Custom timeout value"),
-    ])
-    async def test_timeout(self, monkeypatch: pytest.MonkeyPatch, websocket_connection, timeout, expected):
-        async with CDPConnection.create("ws://localhost:1234/fake", timeout=timeout) as cdp_connection:
-            pass
-        assert cdp_connection.cmd_timeout == expected
-
-
-class TestReaderError:
-    @pytest.mark.trio()
-    async def test_invalid_json(self, caplog: pytest.LogCaptureFixture, websocket_connection: FakeWebsocketConnection):
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with CDPConnection.create("ws://localhost:1234/fake"):
-                assert not websocket_connection.closed
-                await websocket_connection.sender.send("INVALID JSON")
-                await wait_all_tasks_blocked()
-
-        assert str(cm.value) == "Received invalid CDP JSON data: Expecting value: line 1 column 1 (char 0)"
-        assert caplog.records == []
-
-    @pytest.mark.trio()
-    async def test_unknown_session_id(self, caplog: pytest.LogCaptureFixture, websocket_connection: FakeWebsocketConnection):
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with CDPConnection.create("ws://localhost:1234/fake"):
-                assert not websocket_connection.closed
-                await websocket_connection.sender.send("""{"sessionId":"unknown"}""")
-                await wait_all_tasks_blocked()
-
-        assert str(cm.value) == "Unknown CDP session ID: SessionID('unknown')"
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            ("streamlink.webbrowser.cdp.connection", "all", """Received message: {"sessionId":"unknown"}"""),
-        ]
-
-
-class TestSend:
-    @pytest.mark.trio()
-    @pytest.mark.parametrize(("timeout", "jump", "raises"), [
-        pytest.param(
-            None,
-            2 - EPSILON,
-            nullcontext(),
-            id="Default timeout, response in time",
-        ),
-        pytest.param(
-            None,
-            2,
-            pytest.raises(CDPError, match="^Sending CDP message and receiving its response timed out$"),
-            id="Default timeout, response not in time",
-        ),
-        pytest.param(
-            3,
-            3 - EPSILON,
-            nullcontext(),
-            id="Custom timeout, response in time",
-        ),
-        pytest.param(
-            3,
-            3,
-            pytest.raises(CDPError, match="^Sending CDP message and receiving its response timed out$"),
-            id="Custom timeout, response not in time",
-        ),
-    ])
-    async def test_timeout(
-        self,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-        autojump_clock: MockClock,
-        timeout: Optional[float],
-        jump: float,
-        raises: nullcontext,
-    ):
-        assert cdp_connection.cmd_timeout == 2
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        async def response():
-            await trio.sleep(jump)
-            await websocket_connection.sender.send("""{"id":0,"result":{"value":"foo"}}""")
-
-        with raises:
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(partial(cdp_connection.send, fake_command(FakeCommand("foo")), timeout=timeout))
-                nursery.start_soon(response)
-
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == ["""{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}"""]
-
-    @pytest.mark.trio()
-    async def test_closed(
-        self,
-        monkeypatch: pytest.MonkeyPatch,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        # noinspection PyTypeChecker
-        fake_send_message = AsyncMock(side_effect=ConnectionClosed(CloseReason(1000, None)))
-        monkeypatch.setattr(FakeWebsocketConnection, "send_message", fake_send_message)
-
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        with pytest.raises(CDPError) as cm:
-            await cdp_connection.send(fake_command(FakeCommand("foo")))
-
-        assert str(cm.value) == "CloseReason<code=1000, name=NORMAL_CLOSURE, reason=None>"
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_bad_command(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_connection.send, bad_command())
-                nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{}}""")
-
-        assert str(cm.value) == "Generator of CDP command ID 0 did not exit when expected!"
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == ["""{"id":0,"method":"Fake.badCommand","params":{}}"""]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.badCommand","params":{}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{}}""",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_result_exception(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_connection.send, fake_command(FakeCommand("foo")))
-                nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{}}""")
-
-        assert str(cm.value) == "Generator of CDP command ID 0 raised KeyError: 'value'"
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == ["""{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}"""]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{}}""",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_result_success(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        results = {}
-
-        async def send(key):
-            results[key] = await cdp_connection.send(fake_command(FakeCommand(key)))
-
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        async with trio.open_nursery() as nursery:
-            # ensure that we start the tasks in the correct order
-            nursery.start_soon(send, "foo")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(send, "bar")
-            await wait_all_tasks_blocked()
-
-            assert list(cdp_connection.cmd_buffers.keys()) == [0, 1]
-            assert all(buf.response is None for buf in cdp_connection.cmd_buffers.values())
-            assert all(buf.event.is_set() is False for buf in cdp_connection.cmd_buffers.values())
-
-            # send result of second command first
-            nursery.start_soon(websocket_connection.sender.send, """{"id":1,"result":{"value":"BAR"}}""")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{"value":"FOO"}}""")
-
-        assert list(results.keys()) == ["bar", "foo"]
-        assert all(isinstance(result, FakeCommand) for result in results.values())
-        assert results["foo"].value == "FOO"
-        assert results["bar"].value == "BAR"
-
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            """{"id":1,"method":"Fake.fakeCommand","params":{"value":"bar"}}""",
-        ]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":1,"method":"Fake.fakeCommand","params":{"value":"bar"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":1,"result":{"value":"BAR"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{"value":"FOO"}}""",
-            ),
-        ]
-
-
-class TestHandleCmdResponse:
-    @pytest.mark.trio()
-    async def test_unknown_id(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.cmd_buffers == {}
-
-        await websocket_connection.sender.send("""{"id":123}""")
-        await wait_all_tasks_blocked()
-
-        assert cdp_connection.cmd_buffers == {}
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":123}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "warning",
-                "Got a CDP command response with an unknown ID: 123",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_response_error(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_connection.send, fake_command(FakeCommand("foo")))
-                nursery.start_soon(websocket_connection.sender.send, """{"id":0,"error":"Some error message"}""")
-
-        assert str(cm.value) == "Error in CDP command response 0: Some error message"
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == ["""{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}"""]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"error":"Some error message"}""",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_response_no_result(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        with pytest.raises(CDPError) as cm:  # noqa: PT012
-            async with trio.open_nursery() as nursery:
-                nursery.start_soon(cdp_connection.send, fake_command(FakeCommand("foo")))
-                nursery.start_soon(websocket_connection.sender.send, """{"id":0}""")
-
-        assert str(cm.value) == "No result in CDP command response 0"
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == ["""{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}"""]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0}""",
-            ),
-        ]
-
-
-class TestSession:
-    @pytest.fixture()
-    async def cdp_session(self, cdp_connection: CDPConnection):
-        target_id = TargetID("01234")
-        session_id = SessionID("56789")
-        session = cdp_connection.sessions[session_id] = CDPSession(
-            cdp_connection.websocket,
-            target_id=target_id,
-            session_id=session_id,
-            cmd_timeout=cdp_connection.cmd_timeout,
-        )
-        return session
-
-    @pytest.mark.trio()
-    async def test_new_target(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert cdp_connection.sessions == {}
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        session = None
-
-        async def send():
-            nonlocal session
-            session = await cdp_connection.new_target("http://localhost")
-
-        async with trio.open_nursery() as nursery:
-            nursery.start_soon(send)
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{"targetId":"01234"}}""")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":1,"result":{"sessionId":"56789"}}""")
-
-        assert isinstance(session, CDPSession)
-        assert session.target_id == TargetID("01234")
-        assert session.session_id == SessionID("56789")
-        assert cdp_connection.sessions[SessionID("56789")] is session
-
-        assert cdp_connection.cmd_buffers == {}
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Target.createTarget","params":{"url":"http://localhost"}}""",
-            """{"id":1,"method":"Target.attachToTarget","params":{"flatten":true,"targetId":"01234"}}""",
-        ]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Target.createTarget","params":{"url":"http://localhost"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{"targetId":"01234"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":1,"method":"Target.attachToTarget","params":{"flatten":true,"targetId":"01234"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":1,"result":{"sessionId":"56789"}}""",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_session_command(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        cdp_session: CDPSession,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        results = {}
-
-        async def send(obj, key):
-            results[key] = await obj.send(fake_command(FakeCommand(key)))
-
-        assert cdp_connection.cmd_buffers == {}
-        assert cdp_session.cmd_buffers == {}
-        assert websocket_connection.sent == []
-
-        async with trio.open_nursery() as nursery:
-            # ensure that we start the tasks in the correct order
-            nursery.start_soon(send, cdp_connection, "foo")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(send, cdp_session, "bar")
-            await wait_all_tasks_blocked()
-
-            assert list(cdp_connection.cmd_buffers.keys()) == [0]
-            assert list(cdp_session.cmd_buffers.keys()) == [0]
-
-            # send result of second command first
-            nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{"value":"BAR"},"sessionId":"56789"}""")
-            await wait_all_tasks_blocked()
-            nursery.start_soon(websocket_connection.sender.send, """{"id":0,"result":{"value":"FOO"}}""")
-
-        assert list(results.keys()) == ["bar", "foo"]
-        assert all(isinstance(result, FakeCommand) for result in results.values())
-        assert results["foo"].value == "FOO"
-        assert results["bar"].value == "BAR"
-
-        assert cdp_connection.cmd_buffers == {}
-        assert cdp_session.cmd_buffers == {}
-        assert websocket_connection.sent == [
-            """{"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            """{"id":0,"method":"Fake.fakeCommand","params":{"value":"bar"},"sessionId":"56789"}""",
-        ]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Sending message: {"id":0,"method":"Fake.fakeCommand","params":{"value":"bar"},"sessionId":"56789"}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{"value":"BAR"},"sessionId":"56789"}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"id":0,"result":{"value":"FOO"}}""",
-            ),
-        ]
-
-
-class TestHandleEvent:
-    @pytest.fixture(autouse=True)
-    def event_parsers(self, monkeypatch: pytest.MonkeyPatch):
-        event_parsers: Dict[str, Type] = {
-            "Fake.fakeEvent": FakeEvent,
-        }
-        monkeypatch.setattr("streamlink.webbrowser.cdp.devtools.util._event_parsers", event_parsers)
-        return event_parsers
-
-    @pytest.mark.trio()
-    @pytest.mark.parametrize("message", [
-        pytest.param("""{"foo":"bar"}""", id="Missing method and params"),
-        pytest.param("""{"method":"method"}""", id="Missing params"),
-        pytest.param("""{"params":{}}""", id="Missing method"),
-    ])
-    async def test_invalid_event(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-        message: str,
-    ):
-        await websocket_connection.sender.send(message)
-        await wait_all_tasks_blocked()
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                f"Received message: {message}",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "warning",
-                "Invalid CDP event message received without method or params",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_unknown_event(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        await websocket_connection.sender.send("""{"method":"unknown","params":{}}""")
-        await wait_all_tasks_blocked()
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"unknown","params":{}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "warning",
-                "Unknown CDP event message received: unknown",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_eventlistener(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert FakeEvent not in cdp_connection.event_channels
-        listener1 = cdp_connection.listen(FakeEvent)
-        listener2 = cdp_connection.listen(FakeEvent)
-        listener3 = cdp_connection.listen(FakeEvent)
-        listeners = listener1, listener2, listener3
-        assert FakeEvent in cdp_connection.event_channels
-        assert len(cdp_connection.event_channels[FakeEvent]) == 3
-
-        results = []
-
-        async def listen_once(listener: CDPEventListener):
-            async with listener as result:
-                results.append(result)
-
-        async def listen_twice(listener: CDPEventListener):
-            async with listener as result:
-                results.append(result)
-                results.append(await listener.receive())
-
-        async def listen_forever(listener: CDPEventListener):
-            async for result in listener:
-                results.append(result)
-
-        async with trio.open_nursery() as nursery:
-            nursery.start_soon(listen_once, listener1)
-            await wait_all_tasks_blocked()
-            nursery.start_soon(listen_twice, listener2)
-            await wait_all_tasks_blocked()
-            nursery.start_soon(listen_forever, listener3)
-            await wait_all_tasks_blocked()
-
-            await websocket_connection.sender.send("""{"method":"Fake.fakeEvent","params":{"value":"foo"}}""")
-            await wait_all_tasks_blocked()
-            assert len(cdp_connection.event_channels[FakeEvent]) == 3
-
-            await websocket_connection.sender.send("""{"method":"Fake.fakeEvent","params":{"value":"bar"}}""")
-            await wait_all_tasks_blocked()
-            assert len(cdp_connection.event_channels[FakeEvent]) == 2
-
-            await websocket_connection.sender.send("""{"method":"Fake.fakeEvent","params":{"value":"baz"}}""")
-            await wait_all_tasks_blocked()
-            assert len(cdp_connection.event_channels[FakeEvent]) == 1
-
-            await cdp_connection.aclose()
-
-        assert results == [
-            FakeEvent(value="foo"),
-            FakeEvent(value="foo"),
-            FakeEvent(value="foo"),
-            FakeEvent(value="bar"),
-            FakeEvent(value="bar"),
-            FakeEvent(value="baz"),
-        ]
-        assert FakeEvent not in cdp_connection.event_channels
-        assert all(listener._sender._closed for listener in listeners)  # type: ignore[attr-defined]
-        assert all(listener._receiver._closed for listener in listeners)  # type: ignore[attr-defined]
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"Fake.fakeEvent","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                "Received event: FakeEvent(value='foo')",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"Fake.fakeEvent","params":{"value":"bar"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                "Received event: FakeEvent(value='bar')",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"Fake.fakeEvent","params":{"value":"baz"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                "Received event: FakeEvent(value='baz')",
-            ),
-        ]
-
-    @pytest.mark.trio()
-    async def test_would_block(
-        self,
-        caplog: pytest.LogCaptureFixture,
-        cdp_connection: CDPConnection,
-        websocket_connection: FakeWebsocketConnection,
-    ):
-        assert FakeEvent not in cdp_connection.event_channels
-        listener = cdp_connection.listen(FakeEvent, max_buffer_size=1)
-        assert FakeEvent in cdp_connection.event_channels
-        assert len(cdp_connection.event_channels[FakeEvent]) == 1
-
-        assert listener._sender.statistics().current_buffer_used == 0
-        assert listener._sender.statistics().max_buffer_size == 1
-
-        await websocket_connection.sender.send("""{"method":"Fake.fakeEvent","params":{"value":"foo"}}""")
-        await wait_all_tasks_blocked()
-        assert listener._sender.statistics().current_buffer_used == 1
-        assert listener._sender.statistics().max_buffer_size == 1
-
-        await websocket_connection.sender.send("""{"method":"Fake.fakeEvent","params":{"value":"bar"}}""")
-        await wait_all_tasks_blocked()
-        assert listener._sender.statistics().current_buffer_used == 1
-        assert listener._sender.statistics().max_buffer_size == 1
-
-        assert [(record.name, record.levelname, record.message) for record in caplog.records] == [
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"Fake.fakeEvent","params":{"value":"foo"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                "Received event: FakeEvent(value='foo')",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                """Received message: {"method":"Fake.fakeEvent","params":{"value":"bar"}}""",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "all",
-                "Received event: FakeEvent(value='bar')",
-            ),
-            (
-                "streamlink.webbrowser.cdp.connection",
-                "error",
-                """Unable to propagate CDP event FakeEvent(value='bar') due to full channel""",
-            ),
-        ]
diff --git a/tests/webbrowser/conftest.py b/tests/webbrowser/conftest.py
deleted file mode 100644
index 7299d03..0000000
--- a/tests/webbrowser/conftest.py
+++ /dev/null
@@ -1,68 +0,0 @@
-import sys
-from contextlib import asynccontextmanager
-from subprocess import PIPE
-from typing import Optional
-from unittest.mock import Mock
-
-import pytest
-import trio
-
-from streamlink.webbrowser.webbrowser import Webbrowser
-
-
-@pytest.fixture()
-def caplog(caplog: pytest.LogCaptureFixture):
-    caplog.set_level(1, "streamlink")
-    return caplog
-
-
-@pytest.fixture(autouse=True)
-def resolve_executable(request: pytest.FixtureRequest, monkeypatch: pytest.MonkeyPatch):
-    return_value = getattr(request, "param", "default")
-    monkeypatch.setattr("streamlink.webbrowser.webbrowser.resolve_executable", Mock(return_value=return_value))
-    return return_value
-
-
-@pytest.fixture()
-def webbrowser_launch(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture):
-    trio_run_process = trio.run_process
-
-    # use a memory channel, so we can wait until the process has launched
-    sender: trio.MemorySendChannel[trio.Process]
-    receiver: trio.MemoryReceiveChannel[trio.Process]
-    sender, receiver = trio.open_memory_channel(1)
-
-    async def fake_trio_run_process(*args, task_status, **kwargs):
-        task_status_started = task_status.started
-
-        def fake_task_status_started(process: trio.Process):
-            task_status_started(process)
-            sender.send_nowait(process)
-
-        # intercept the task status report
-        task_status.started = fake_task_status_started
-        # override the stdin parameter, so we can send data to our dummy process
-        kwargs["stdin"] = PIPE
-
-        return await trio_run_process(*args, task_status=task_status, **kwargs)
-
-    monkeypatch.setattr("trio.run_process", fake_trio_run_process)
-
-    @asynccontextmanager
-    async def webbrowser_launch(*args, webbrowser: Optional[Webbrowser] = None, **kwargs):
-        # dummy web browser process, which idles until stdin receives input with an exit code
-        webbrowser = webbrowser or Webbrowser()
-        webbrowser.executable = sys.executable
-        webbrowser.arguments = ["-c", "import sys; sys.exit(int(sys.stdin.readline()))", *webbrowser.arguments]
-
-        async with webbrowser.launch(*args, **kwargs) as nursery:
-            assert isinstance(nursery, trio.Nursery)
-            assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-                ("streamlink.webbrowser.webbrowser", "info", f"Launching web browser: {sys.executable}"),
-            ]
-            caplog.records.clear()
-            # wait until the process has launched, so we can test it
-            process = await receiver.receive()
-            yield nursery, process
-
-    return webbrowser_launch
diff --git a/tests/webbrowser/test_chromium.py b/tests/webbrowser/test_chromium.py
deleted file mode 100644
index 76a37be..0000000
--- a/tests/webbrowser/test_chromium.py
+++ /dev/null
@@ -1,182 +0,0 @@
-from contextlib import nullcontext
-from pathlib import Path, PurePosixPath, PureWindowsPath
-from signal import SIGTERM
-from typing import Any, Dict, List, Optional
-
-import pytest
-import requests_mock as rm
-import trio
-from requests import Timeout
-
-from streamlink.compat import is_win32
-from streamlink.exceptions import PluginError
-from streamlink.session import Streamlink
-from streamlink.webbrowser.chromium import ChromiumWebbrowser
-from streamlink.webbrowser.exceptions import WebbrowserError
-
-
-class TestInit:
-    @pytest.mark.parametrize(("executable", "resolve_executable", "raises"), [
-        pytest.param(
-            None,
-            None,
-            pytest.raises(WebbrowserError, match="^Could not find Chromium-based web browser executable: Please set the path "),
-            id="Failure with unset path",
-        ),
-        pytest.param(
-            "custom",
-            None,
-            pytest.raises(WebbrowserError, match="^Invalid web browser executable: custom$"),
-            id="Failure with custom path",
-        ),
-        pytest.param(
-            None,
-            "default",
-            nullcontext(),
-            id="Success with default path",
-        ),
-        pytest.param(
-            "custom",
-            "custom",
-            nullcontext(),
-            id="Success with custom path",
-        ),
-    ], indirect=["resolve_executable"])
-    def test_resolve_executable(self, resolve_executable, executable: Optional[str], raises: nullcontext):
-        with raises:
-            ChromiumWebbrowser(executable=executable)
-
-
-class TestFallbacks:
-    def test_win32(self, monkeypatch: pytest.MonkeyPatch):
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_win32", True)
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_darwin", False)
-        monkeypatch.setattr("streamlink.webbrowser.chromium.Path", PureWindowsPath)
-        monkeypatch.setattr("os.getenv", {
-            "PROGRAMFILES": "C:\\Program Files",
-            "PROGRAMFILES(X86)": "C:\\Program Files (x86)",
-            "LOCALAPPDATA": "C:\\Users\\user\\AppData\\Local",
-        }.get)
-        assert ChromiumWebbrowser.fallback_paths() == [
-            "C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe",
-            "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",
-            "C:\\Program Files\\Microsoft\\Edge Beta\\Application\\msedge.exe",
-            "C:\\Program Files (x86)\\Microsoft\\Edge Beta\\Application\\msedge.exe",
-            "C:\\Program Files\\Microsoft\\Edge Dev\\Application\\msedge.exe",
-            "C:\\Program Files (x86)\\Microsoft\\Edge Dev\\Application\\msedge.exe",
-            "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
-            "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",
-            "C:\\Users\\user\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe",
-            "C:\\Program Files\\Google\\Chrome Beta\\Application\\chrome.exe",
-            "C:\\Program Files (x86)\\Google\\Chrome Beta\\Application\\chrome.exe",
-            "C:\\Users\\user\\AppData\\Local\\Google\\Chrome Beta\\Application\\chrome.exe",
-            "C:\\Program Files\\Google\\Chrome Canary\\Application\\chrome.exe",
-            "C:\\Program Files (x86)\\Google\\Chrome Canary\\Application\\chrome.exe",
-            "C:\\Users\\user\\AppData\\Local\\Google\\Chrome Canary\\Application\\chrome.exe",
-        ]
-
-    def test_darwin(self, monkeypatch: pytest.MonkeyPatch):
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_win32", False)
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_darwin", True)
-        monkeypatch.setattr("streamlink.webbrowser.chromium.Path", PurePosixPath)
-        PurePosixPath.home = lambda: PurePosixPath("/Users/user")  # type: ignore[attr-defined]
-        assert ChromiumWebbrowser.fallback_paths() == [
-            "/Applications/Chromium.app/Contents/MacOS/Chromium",
-            "/Users/user/Applications/Chromium.app/Contents/MacOS/Chromium",
-            "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
-            "/Users/user/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
-        ]
-
-    def test_other(self, monkeypatch: pytest.MonkeyPatch):
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_win32", False)
-        monkeypatch.setattr("streamlink.webbrowser.chromium.is_darwin", False)
-        assert ChromiumWebbrowser.fallback_paths() == []
-
-
-class TestLaunchArgs:
-    def test_launch_args(self):
-        webbrowser = ChromiumWebbrowser()
-        assert "--password-store=basic" in webbrowser.arguments
-        assert "--use-mock-keychain" in webbrowser.arguments
-        assert "--headless=new" in webbrowser.arguments
-        assert not any(arg.startswith("--remote-debugging-host") for arg in webbrowser.arguments)
-        assert not any(arg.startswith("--remote-debugging-port") for arg in webbrowser.arguments)
-        assert not any(arg.startswith("--user-data-dir") for arg in webbrowser.arguments)
-
-    @pytest.mark.parametrize("headless", [True, False])
-    def test_headless(self, headless: bool):
-        webbrowser = ChromiumWebbrowser(headless=headless)
-        assert ("--headless=new" in webbrowser.arguments) is headless
-
-
-@pytest.mark.trio()
-@pytest.mark.parametrize("host", ["127.0.0.1", "::1"])
-@pytest.mark.parametrize("port", [None, 1234])
-async def test_launch(monkeypatch: pytest.MonkeyPatch, mock_clock, webbrowser_launch, host, port):
-    async def fake_find_free_port(_):
-        return 1234
-
-    monkeypatch.setattr("streamlink.webbrowser.chromium.find_free_port_ipv4", fake_find_free_port)
-    monkeypatch.setattr("streamlink.webbrowser.chromium.find_free_port_ipv6", fake_find_free_port)
-
-    webbrowser = ChromiumWebbrowser(host=host, port=port)
-
-    nursery: trio.Nursery
-    process: trio.Process
-    async with webbrowser_launch(webbrowser=webbrowser, timeout=999) as (nursery, process):  # noqa: F841
-        assert process.poll() is None, "process is still running"
-        assert f"--remote-debugging-host={host}" in process.args
-        assert "--remote-debugging-port=1234" in process.args
-        param_user_data_dir = next(  # pragma: no branch
-            (arg for arg in process.args if arg.startswith("--user-data-dir=")),
-            None,
-        )
-        assert param_user_data_dir is not None
-
-        user_data_dir = Path(param_user_data_dir[len("--user-data-dir="):])
-        assert user_data_dir.exists()
-
-        # turn the 0.5s sleep() call at the end into a 0.5ms sleep() call
-        # autojump_clock=0 would trigger the process's kill() fallback immediately and raise a warning
-        mock_clock.rate = 1000
-
-    assert process.poll() == (1 if is_win32 else -SIGTERM), "Process has been terminated"
-    assert not user_data_dir.exists()
-
-
-@pytest.mark.parametrize(("host", "port"), [
-    pytest.param("127.0.0.1", 1234, id="IPv4"),
-    pytest.param("::1", 1234, id="IPv6"),
-])
-@pytest.mark.parametrize(("num", "raises"), [
-    pytest.param(10, nullcontext(), id="Success"),
-    pytest.param(11, pytest.raises(PluginError), id="Timeout/Failure"),
-])
-def test_get_websocket_address(
-    monkeypatch: pytest.MonkeyPatch,
-    requests_mock: rm.Mocker,
-    session: Streamlink,
-    host: str,
-    port: int,
-    num: int,
-    raises: nullcontext,
-):
-    monkeypatch.setattr("time.sleep", lambda _: None)
-
-    payload = {
-      "Browser": "Chrome/114.0.5735.133",
-      "Protocol-Version": "1.3",
-      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
-      "V8-Version": "11.4.183.23",
-      "WebKit-Version": "537.36 (@fbfa2ce68d01b2201d8c667c2e73f648a61c4f4a)",
-      "webSocketDebuggerUrl": f"ws://{host}:{port}/devtools/browser/some-uuid4",
-    }
-
-    for address in ("http://127.0.0.1:1234/json/version", "http://[::1]:1234/json/version"):
-        responses: List[Dict[str, Any]] = [{"exc": Timeout()} for _ in range(num)]
-        responses.append({"json": payload})
-        requests_mock.register_uri("GET", address, responses)
-
-    webbrowser = ChromiumWebbrowser(host=host, port=port)
-    with raises:
-        assert webbrowser.get_websocket_url(session) == f"ws://{host}:{port}/devtools/browser/some-uuid4"
diff --git a/tests/webbrowser/test_webbrowser.py b/tests/webbrowser/test_webbrowser.py
deleted file mode 100644
index a1b86d1..0000000
--- a/tests/webbrowser/test_webbrowser.py
+++ /dev/null
@@ -1,144 +0,0 @@
-from __future__ import annotations
-
-from contextlib import AbstractContextManager, nullcontext
-from pathlib import Path
-from signal import SIGTERM
-from typing import List, Optional
-
-import pytest
-import trio
-
-from streamlink.compat import is_win32
-from streamlink.webbrowser.exceptions import WebbrowserError
-from streamlink.webbrowser.webbrowser import Webbrowser
-
-
-class _FakeWebbrowser(Webbrowser):
-    @classmethod
-    def launch_args(cls) -> List[str]:
-        return ["foo", "bar"]
-
-
-class TestInit:
-    @pytest.mark.parametrize(("executable", "resolve_executable", "raises"), [
-        pytest.param(
-            None,
-            None,
-            pytest.raises(WebbrowserError, match="^Could not find web browser executable: Please set the path "),
-            id="Failure with unset path",
-        ),
-        pytest.param(
-            "custom",
-            None,
-            pytest.raises(WebbrowserError, match="^Invalid web browser executable: custom$"),
-            id="Failure with custom path",
-        ),
-        pytest.param(
-            None,
-            "default",
-            nullcontext(),
-            id="Success with default path",
-        ),
-        pytest.param(
-            "custom",
-            "custom",
-            nullcontext(),
-            id="Success with custom path",
-        ),
-    ], indirect=["resolve_executable"])
-    def test_resolve_executable(self, resolve_executable, executable: Optional[str], raises: nullcontext):
-        with raises:
-            Webbrowser(executable=executable)
-
-    def test_arguments(self):
-        webbrowser = _FakeWebbrowser()
-        assert webbrowser.executable == "default"
-        assert webbrowser.arguments == ["foo", "bar"]
-        assert webbrowser.arguments is not _FakeWebbrowser.launch_args()
-
-
-class TestLaunch:
-    @pytest.mark.trio()
-    async def test_terminate_on_nursery_exit(self, caplog: pytest.LogCaptureFixture, webbrowser_launch):
-        nursery: trio.Nursery
-        process: trio.Process
-        async with webbrowser_launch() as (nursery, process):  # noqa: F841
-            assert process.poll() is None, "process is still running"
-
-        assert process.poll() == (1 if is_win32 else -SIGTERM), "Process has been terminated"
-        assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-            ("streamlink.webbrowser.webbrowser", "debug", "Waiting for web browser process to terminate"),
-        ]
-
-    @pytest.mark.trio()
-    async def test_terminate_on_nursery_cancellation(self, caplog: pytest.LogCaptureFixture, webbrowser_launch):
-        nursery: trio.Nursery
-        process: trio.Process
-        async with webbrowser_launch() as (nursery, process):
-            assert process.poll() is None, "process is still running"
-            nursery.cancel_scope.cancel()
-
-        assert process.poll() == (1 if is_win32 else -SIGTERM), "Process has been terminated"
-        assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-            ("streamlink.webbrowser.webbrowser", "debug", "Waiting for web browser process to terminate"),
-        ]
-
-    @pytest.mark.trio()
-    async def test_terminate_on_nursery_timeout(self, caplog: pytest.LogCaptureFixture, mock_clock, webbrowser_launch):
-        nursery: trio.Nursery
-        process: trio.Process
-        async with webbrowser_launch(timeout=10) as (nursery, process):  # noqa: F841
-            assert process.poll() is None, "process is still running"
-            mock_clock.jump(20)
-            await trio.sleep(0)
-
-        assert process.poll() == (1 if is_win32 else -SIGTERM), "Process has been terminated"
-        assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-            ("streamlink.webbrowser.webbrowser", "warning", "Web browser task group has timed out"),
-            ("streamlink.webbrowser.webbrowser", "debug", "Waiting for web browser process to terminate"),
-        ]
-
-    @pytest.mark.trio()
-    async def test_terminate_on_nursery_baseexception(self, caplog: pytest.LogCaptureFixture, webbrowser_launch):
-        class FakeBaseException(BaseException):
-            pass
-
-        nursery: trio.Nursery
-        process: trio.Process
-        with pytest.raises(FakeBaseException):  # noqa: PT012
-            async with webbrowser_launch() as (nursery, process):  # noqa: F841
-                assert process.poll() is None, "process is still running"
-                raise FakeBaseException()
-
-        assert process.poll() == (1 if is_win32 else -SIGTERM), "Process has been terminated"
-        assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-            ("streamlink.webbrowser.webbrowser", "debug", "Waiting for web browser process to terminate"),
-        ]
-
-    # don't run on Windows, because of some weird flaky subprocess early-termination issues
-    @pytest.mark.posix_only()
-    @pytest.mark.trio()
-    # don't check for non-zero exit codes - we don't care
-    @pytest.mark.parametrize("exit_code", [0, 1])
-    async def test_process_ended_early(self, caplog: pytest.LogCaptureFixture, webbrowser_launch, exit_code):
-        nursery: trio.Nursery
-        process: trio.Process
-        async with webbrowser_launch(timeout=10) as (nursery, process):  # noqa: F841
-            assert process.poll() is None, "process is still running"
-            assert process.stdin
-            await process.stdin.send_all(str(exit_code).encode() + b"\r\n")
-            await trio.sleep(5)
-
-        assert process.poll() == exit_code, "Process has ended with the right exit code"
-        assert [(record.name, record.levelname, record.msg) for record in caplog.records] == [
-            ("streamlink.webbrowser.webbrowser", "warning", "Web browser process ended early"),
-        ]
-
-
-def test_temp_dir():
-    webbrowser = Webbrowser()
-    temp_dir = webbrowser._create_temp_dir()
-    assert isinstance(temp_dir, AbstractContextManager)
-    with temp_dir as path:
-        assert Path(path).exists()
-    assert not Path(path).exists()
