From: Alexis Murzeau <amubtdx@gmail.com>
Date: Tue, 9 Apr 2024 16:26:21 +0000
Subject: twitch,webbrowser: unwrap single exception BaseExceptionGroup

This is not done automatically on Debian Bookworm which use an older version of exceptiongroup.
See: https://github.com/agronholm/exceptiongroup/commit/821d5ebaadfd0b5b16c785a942f69e89933217bf

Forwarded: https://github.com/streamlink/streamlink/issues/5929
Author: Alexis Murzeau <amubtdx@gmail.com>
---
 src/streamlink/plugins/twitch.py        | 24 +++++++-----
 src/streamlink/webbrowser/webbrowser.py | 66 ++++++++++++++++++---------------
 2 files changed, 51 insertions(+), 39 deletions(-)

diff --git a/src/streamlink/plugins/twitch.py b/src/streamlink/plugins/twitch.py
index b4bb8f1..4e5e8c4 100644
--- a/src/streamlink/plugins/twitch.py
+++ b/src/streamlink/plugins/twitch.py
@@ -569,15 +569,21 @@ class TwitchClientIntegrity:
             for err in exc_grp.exceptions:
                 log.error(f"{type(err).__name__}: {err}")
 
-        with catch({  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
-            Exception: handle_error,  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
-        }):
-            client_integrity = CDPClient.launch(
-                session,
-                acquire_client_integrity_token,
-                # headless mode gets detected by Twitch, so we have to disable it regardless the user config
-                headless=False,
-            )
+        try:
+            with catch({  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
+                Exception: handle_error,  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
+            }):
+                client_integrity = CDPClient.launch(
+                    session,
+                    acquire_client_integrity_token,
+                    # headless mode gets detected by Twitch, so we have to disable it regardless the user config
+                    headless=False,
+                )
+        # Unwrap single exception as done in exceptiongroup v1.2.0
+        except BaseExceptionGroup as exc:
+            if len(exc.exceptions) == 1:
+                raise exc.exceptions[0]
+            raise exc
 
         if not client_integrity:
             return None
diff --git a/src/streamlink/webbrowser/webbrowser.py b/src/streamlink/webbrowser/webbrowser.py
index 3e6f57b..3f7d7c6 100644
--- a/src/streamlink/webbrowser/webbrowser.py
+++ b/src/streamlink/webbrowser/webbrowser.py
@@ -83,36 +83,42 @@ class _WebbrowserLauncher:
         def handle_baseexception(exc_grp: BaseExceptionGroup) -> None:
             raise exc_grp.exceptions[0] from exc_grp.exceptions[0].__context__
 
-        with catch({  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
-            (KeyboardInterrupt, SystemExit): handle_baseexception,  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
-        }):
-            async with trio.open_nursery() as nursery:
-                log.info(f"Launching web browser: {self.executable}")
-                # the process is run in a separate task
-                run_process = partial(
-                    trio.run_process,
-                    [self.executable, *self.arguments],
-                    check=False,
-                    stdout=DEVNULL,
-                    stderr=DEVNULL,
-                )
-                # trio ensures that the process gets terminated when the task group gets cancelled
-                process: trio.Process = await nursery.start(run_process)
-                # the process watcher task cancels the entire task group when the user terminates/kills the process
-                nursery.start_soon(self._task_process_watcher, process, nursery)
-                try:
-                    # the application logic is run here
-                    with trio.move_on_after(self.timeout) as cancel_scope:
-                        yield nursery
-                    # check if the application logic has timed out
-                    if cancel_scope.cancelled_caught:
-                        log.warning("Web browser task group has timed out")
-                finally:
-                    # check if the task group hasn't been cancelled yet in the process watcher task
-                    if not self._process_ended_early:
-                        log.debug("Waiting for web browser process to terminate")
-                    # once the application logic is done, cancel the entire task group and terminate/kill the process
-                    nursery.cancel_scope.cancel()
+        try:
+            with catch({  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
+                (KeyboardInterrupt, SystemExit): handle_baseexception,  # type: ignore[dict-item]  # bug in exceptiongroup==1.2.0
+            }):
+                async with trio.open_nursery() as nursery:
+                    log.info(f"Launching web browser: {self.executable}")
+                    # the process is run in a separate task
+                    run_process = partial(
+                        trio.run_process,
+                        [self.executable, *self.arguments],
+                        check=False,
+                        stdout=DEVNULL,
+                        stderr=DEVNULL,
+                    )
+                    # trio ensures that the process gets terminated when the task group gets cancelled
+                    process: trio.Process = await nursery.start(run_process)
+                    # the process watcher task cancels the entire task group when the user terminates/kills the process
+                    nursery.start_soon(self._task_process_watcher, process, nursery)
+                    try:
+                        # the application logic is run here
+                        with trio.move_on_after(self.timeout) as cancel_scope:
+                            yield nursery
+                        # check if the application logic has timed out
+                        if cancel_scope.cancelled_caught:
+                            log.warning("Web browser task group has timed out")
+                    finally:
+                        # check if the task group hasn't been cancelled yet in the process watcher task
+                        if not self._process_ended_early:
+                            log.debug("Waiting for web browser process to terminate")
+                        # once the application logic is done, cancel the entire task group and terminate/kill the process
+                        nursery.cancel_scope.cancel()
+        # Unwrap single exception as done in exceptiongroup v1.2.0
+        except BaseExceptionGroup as exc:
+            if len(exc.exceptions) == 1:
+                raise exc.exceptions[0]
+            raise exc
 
     async def _task_process_watcher(self, process: trio.Process, nursery: trio.Nursery) -> None:
         """Task for cancelling the launch task group if the user closes the browser or if it exits early on its own"""
